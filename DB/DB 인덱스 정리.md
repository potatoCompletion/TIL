# <DB 인덱스>
**효율적인 DB 설계 및 튜닝을 위해 필수적인 인덱스**  
<br />
<br />
<br />

## DB 인덱스란?
- 인덱스는 데이터 저장, 수정, 삭제에 대한 성능을 희생시켜 탐색에 대한 성능을 대폭 상승하는 방식이라고 볼 수 있다.  
  인덱스는 B-tree 자료구조를 이용하여 테이블의 요소를 빠르게 탐색하도록 설계되어있다.

## DB 인덱스의 단점
- 인덱스는 조회(SELECT)를 제외한 모든 동작. 즉, INSERT/UPDATE/DELETE 성능에 영향을 미친다.  
  인덱스 테이블(복사된 테이블)의 수정도 같이 필요하기 때문에 삽입/수정/삭제 작업이 두 번 일어나게 된다.
- 인덱스는 별도의 공간에 해당 컬럼을 저장해야 하기 때문에 추가 저장 공간이 필요하다.  
  인덱스를 사용하는 시스템을 설계할 때, 인덱스 영역을 전체 테이블 영역의 30 ~ 50% 까지 잡아 놓을 만큼 저장 공간이 꽤나 많이 필요하다.

## 그럼에도 인덱스가 필수인 이유?
- 일반적인 OLTP(OnLine Transaction Processing) 시스템에서 데이터 조회 업무가 90% 이상이기 때문이다.  
  조회 업무의 검색 속도 향상은 시스템 부하를 감소시켜, 같은 시간 내에 더 많은 업무 처리가 가능해진다.  
  그렇기 때문에 위의 단점에서 알 수 있듯,


    1. 규모가 작지 않은 테이블에서  
    2. INSERT / UPDATE / DELETE가 자주 발생하지 않는 컬럼,  
    3. 혹은 JOIN / WHERE / ORDER BY에 자주 사용되는 컬럼,  
    4. 혹은 데이터의 중복도가 낮은 컬럼

    에 인덱스를 사용하면 좋다.

## 정렬 되어 있을 때 이진탐색이 아니라 btree 를 사용하는 이유?
- 일반적인 Tree는 시간 복잡도로 O(logN) 을 갖는다.  
  그러나 트리 노드의 요소가 한쪽으로 쏠리게 되면, 시간 복잡도가 O(N)을 갖게 되어 List와 별반 다를 것이 없어진다.  
  이러한 경우를 방지하기 위해서 인덱스에서는 밸런스 트리를 사용한다.

## 밸런스 트리?
- 트리의 노드가 한 방향으로 쏠리지 않도록, 노드 삽입 및 삭제 시 특정 규칙에 맞게 재정렬되어 왼쪽과 오른쪽 자식 양쪽 수의 밸런스를 유지하는 트리이다.  
  항상 양쪽 자식의 밸런스를 유지하므로 무조건 O(logN)의 시간 복잡도를 보장한다.  
  다만, 재정렬되는 작업으로 인해 노드 삽입 및 삭제 시 일반적인 트리보다 성능이 떨어진다.  
  그러므로 밸런스 트리는 삽입/삭제의 성능을 희생하고 탐색에 대한 성능을 높였다고 볼 수 있다.  
  대표적으로 RedBlack-Tree, B-Tree가 있다.

## 시간 복잡도가 더 낮은 해시 테이블을 사용하지 않는 이유?
- 해시 테이블은 해시 함수를 통해 나온 해시 값을 이용하여 저장된 메모리 공간에 한 번에 접근을 하기 때문에 O(1)이라는 시간 복잡도를 가진다.  
  (물론 해시 충돌 등으로 최악의 경우에 O(N)이 될 수 있지만, 평균적으로는 O(1)으로 볼 수 있다)  
  그러나 이는 온전히 '단 하나의 데이터를 탐색하는 시간'에만 O(1)이다.  
  우리는 DB에서 하나의 값 만을 찾는 것이 아니라, 등호(<, >)를 사용하기도 한다.  
  모든 값이 정렬되어 있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 수 없다.  
  그래서 기준 값보다 크거나 작은 요소들을 탐색할 수 있어야하는 DB 인덱스 용도로 해시 테이블은 어울리지 않는 자료구조이다.

## RedBlack-Tree가 선택받지 못한 이유?
- RedBlack-Tree는 각 노드가 하나의 값만 가진 상태로 좌, 우 자식 노드의 개수 밸런스를 맞춘다.  
  B-tree는 하나의 노드에 여러 데이터가 저장 될 수 있다. 노드 내 데이터들은 항상 정렬된 상태이며, 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다.  
  이처럼, 두 개의 트리는 항상 좌, 우 자식노드 개수의 밸런스를 유지하므로 최악의 경우에도 무조건 탐색 시간이 O(logN)을 가지게 된다.  
  하지만 이 두 개의 트리는 큰 차이점이 있는데, 위에서 언급한대로 하나의 노드에 저장할 수 있는 데이터의 수이다.  
  B-tree는 하나의 노드에 여러 데이터들이 배열처럼 정렬이 되어있다.  
  실제 메모리 상에 차례대로 저장이 되어있기 때문에 같은 노드 공간의 데이터들끼리 굳이 자식 노드처럼 참조 포인터 값으로 접근할 필요가 없다.  
  이러한 특징은 연산속도에서 차이를 불러온다.  
  참조 포인터로 메모리에 접근한다는 것은, 실제 메모리 상 순서대로 저장이 되었든 안 되었든 접근하려는 주소를 연산을 통해 직접 알아내어 데이터에 접근한다는 것이다.  
  이 때 CPU 내부적으로 많은 연산을 수행하게 될 것이다.  
  반대로 배열은 데이터들이 메모리 공간에 차례대로 저장이 되어 있으므로 접근할 주소를 바로 알 수 있다.  
  그래서 주소를 알아내는데 성능에 영향이 없다.  
  이러한 사소한 차이는 데이터량이 커지면 커질수록 확연하게 드러나게 되기 때문에, DB 인덱스에서는 B-tree를 자료구조로 이용한다고 할 수 있다.

## 그렇다면 그냥 배열을 쓰면 가장 빠르게 조회가 가능하지 않나?
- 맞다. 조회 속도만 따지면 배열이 가장 빠를 수 있다.  
  해시 테이블과는 다르게 데이터들을 정렬 상태로 유지할 수 있으므로 부등호(<, >) 연산에도 문제가 없다.  
  하지만, 배열이 B-tree보다 빠른 것은 '탐색' 뿐이다.  
  배열 내에서 데이터 삽입, 삭제가 일어나는 순간 얘기가 달라진다.  
  배열은 중간에 요소를 삽입할 경우, 모든 데이터의 이동이 일어나야 한다.  
  이 때 뒤로 한 칸씩 이동하는 과정에서 평균 시간 복잡도가 O(N)이 걸리게 된다.  
  이는 삭제 시에도 동일하게 적용된다.  
  이러한 특성 때문에 배열 또한 DB 인덱스에 어울리는 자료구조가 아니라고 할 수 있다.

## 그럼 삽입, 삭제가 쉬운 링크드리스트가 있지 않나?
- 배열이 탐색이 빠른 이유가 무엇일까?  
  정렬이 되어있는 배열은 이진탐색이 가능하고 이는 O(logN)의 시간을 보장한다.  
  정렬이 되어있지 않은 경우, Quick Sort, Merge Sort 등의 시간 복잡도가 Average O(NlogN)인 알고리즘을 사용한다면 빠르게 정렬을 시킬 수 있다.  
  하지만 이 알고리즘들은 어떻게 작동하는가? 배열의 총 길이를 알아야하고, Index Number가 파악이 가능해야 하다.  
  링크드리스트에는 Index Number라는 개념이 없다.  
  따라서 무조건 가장 앞 부분인 'HEAD'부터 탐색을 시작해야 하는 링크드리스트는 DB 인덱스로 사용하기에 어울리는 자료구조가 아니라고 할 수 있다.

# 정리
모든 면에서 DB 인덱스 용도로 가장 적합한 자료구조인 B-Tree
1. 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
2. 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.
3. 데이터 탐색뿐 아니라 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.


## 추가해서 정리할 주제
1. b+tree
- 대부분 rdbms는 b+tree를 구현합니다.  
  하지만 오라클, Mysql 등 공식 문서에서는 b tree라고 명시합니다.(학술적으로 정의된 자료구조가 아니기 때문입니다. 단지 b tree의 변형된 형태이기 때문입니다)  
  그렇다면 왜 b+tree를 사용할까요? 이는 블록 지향 저장소에 최적화된 즉, 하드 디스크에 무언가 저장하기 적절한 구조이기 때문입니다.  
  b tree는 일반 binary tree와 달리 노드를 여러개 가질 수가 있고 이것이 '범위 검색'에 매우 최적화된 구조입니다.  
  왜냐하면 하드 디스크는 디스크 암이 하나의 블록을 읽는데 이 블록은 하드 디스크가 회전하며 읽을 수가 있습니다.  
  랜덤하게 읽는다면 범위 검색에 말이 무색하지만 '순차적으로' 읽을 땐, 굉장히 효율적인 구조입니다.  
  예를 들어 a~z까지 리프 노드가 있고 여기서 e~h까지 '순차적으로' 읽어야 한다면,  
  리프 노드가 '순차적으로' 구성된 상태에서 e까지 찾아간 다음에 h까지 순차IO로 한 번에 읽어 올 수가 있습니다.  
  그래서 많은 dbms가 b tree 구조를 통해서 데이터를 저장하고 관리하는 것 입니다.  